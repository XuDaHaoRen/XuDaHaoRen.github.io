<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.xuboluo666.com/atom.xml" rel="self"/>
  
  <link href="http://www.xuboluo666.com/"/>
  <updated>2022-06-10T16:10:50.449Z</updated>
  <id>http://www.xuboluo666.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://www.xuboluo666.com/2022/06/11/6.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://www.xuboluo666.com/2022/06/11/6.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-06-10T16:10:50.449Z</published>
    <updated>2022-06-10T16:10:50.449Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 栈和队列<br>toc: true</p><hr><h1 id="1-栈-Stack"><a href="#1-栈-Stack" class="headerlink" title="1.栈 Stack"></a>1.栈 Stack</h1><h2 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h2><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202201042105482.png" alt="image-20220104210515422" style="zoom:50%;" /><p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也**不提供迭代器(iterator)**。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p><p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p><h2 id="1-2-栈的应用"><a href="#1-2-栈的应用" class="headerlink" title="1.2 栈的应用"></a>1.2 栈的应用</h2><h3 id="1-2-1括号和-HTML-匹配"><a href="#1-2-1括号和-HTML-匹配" class="headerlink" title="1.2.1括号和 HTML 匹配"></a>1.2.1括号和 HTML 匹配</h3><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062348381.png" alt="image-20210924145107259"></p><p>1.算法描述</p><p>每次遇到一个开始符时都将其压入栈中；每次遇到一个结束符时，从栈顶弹出一个分隔符，并检查这两个分割符是否可以凑成一对。</p><p>具体题目详见：<a href="https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/">LeetCode题目链接</a></p><h3 id="1-2-2-栈的现实应用"><a href="#1-2-2-栈的现实应用" class="headerlink" title="1.2.2 栈的现实应用"></a>1.2.2 栈的现实应用</h3><p><strong>1.网页后退按钮的操作</strong></p><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062348617.png" alt="image-20210924145343275"></p><p>浏览器将浏览的网页存在一个栈中，当用户浏览一个新网页时，这个网页就被压入栈顶。这样用户在点击后退按钮的时候，就会弹出刚刚访问的地址</p><p><strong>2.文本编辑器的撤销机制</strong></p><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349871.png" alt="image-20210924145449113"></p><p>撤销机制会取消最近的编辑操作并回到最原先的文本状态</p><h2 id="1-4-栈的底层实现"><a href="#1-4-栈的底层实现" class="headerlink" title="1.4 栈的底层实现"></a>1.4 栈的底层实现</h2><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202201042113243.png" alt="image-20220104211353197" style="zoom:50%;" /><p>从上图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p><p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure><h1 id="2-队列-queue"><a href="#2-队列-queue" class="headerlink" title="2.队列 queue"></a>2.队列 queue</h1><h2 id="2-1-队列定义"><a href="#2-1-队列定义" class="headerlink" title="2.1 队列定义"></a>2.1 队列定义</h2><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349491.png" alt="image-20210921231003500"></p><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p><h2 id="2-2-队列的应用"><a href="#2-2-队列的应用" class="headerlink" title="2.2 队列的应用"></a>2.2 队列的应用</h2><h2 id="2-2-1-现实场景应用"><a href="#2-2-1-现实场景应用" class="headerlink" title="2.2.1 现实场景应用"></a>2.2.1 现实场景应用</h2><p><strong>1.网络打印机</strong></p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349581.png" alt="image-20210924150726425" style="zoom:50%;" /><p><strong>2.响应 Web 请求</strong></p><p><strong>3.操作系统中页面置换算法</strong></p><h3 id="2-4-3假溢出问题"><a href="#2-4-3假溢出问题" class="headerlink" title="2.4.3假溢出问题"></a>2.4.3假溢出问题</h3><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349005.png" alt="image-20210924154116257"></p><p>假溢出：顺序队列因多次入队和出队的操作出现尚有存储空间但是无法再进行入队操作的溢出</p><h2 id="2-5-循环队列"><a href="#2-5-循环队列" class="headerlink" title="2.5 循环队列"></a>2.5 循环队列</h2><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349794.png" alt="image-20210924154357165"></p><p>上图来自百度百科。为充分利用向量空间，克服”假溢出”现象，把顺序队列首尾相连，这样存储元素的表从逻辑上看做是一个环。</p><h3 id="2-5-1循环队列指针移动"><a href="#2-5-1循环队列指针移动" class="headerlink" title="2.5.1循环队列指针移动"></a>2.5.1循环队列指针移动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化：Q.front==Q.rear==<span class="number">0</span></span><br><span class="line">入队：Q.front = (Q.front+<span class="number">1</span>)%Maxsize</span><br><span class="line">出队：Q.rear = (Q.rear+<span class="number">1</span>)%Maxsize</span><br><span class="line">队长：(Q.rear+Maxsize-Q.front)%Maxsize</span><br></pre></td></tr></table></figure><p>取模的作用就是防止 front  或者 rear 一直 +1 导致内存地址溢出，而取模可以将 front 和 rear 的值固定在 Maxsize 大小的范围</p><h3 id="2-5-2顺序-amp-循环队列判断队空和队满"><a href="#2-5-2顺序-amp-循环队列判断队空和队满" class="headerlink" title="2.5.2顺序&amp;循环队列判断队空和队满"></a>2.5.2顺序&amp;循环队列判断队空和队满</h3><p>有三种方法可以判断一个队列是空还是满</p><p><strong>1.牺牲一个单元</strong></p><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349542.png" alt="image-20210924160728531"></p><p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349673.png" alt="image-20210924160745472"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">队空：Q.front==Q.rear</span><br><span class="line">队满：(Q.front+<span class="number">1</span>)%Maxsize==Q.rear</span><br></pre></td></tr></table></figure><p><strong>2.设置变量用于计数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">队空：Q._size == <span class="number">0</span></span><br><span class="line">队满：Q._size == Maxsize</span><br></pre></td></tr></table></figure><p><strong>3.设置一个 tag 对最后一次操作进行记录</strong></p><ol><li></li></ol><p>如果最后一次操作是出队操作：设置 tag&#x3D;0</p><p>当 Q.front&#x3D;&#x3D;Q.rear 且 tag&#x3D;0 ，则可判断为队空</p><ol start="2"><li></li></ol><p>如果最后一次操作是入队操作：设置 tag&#x3D;1</p><p>当 Q.front&#x3D;&#x3D;Q.rear 且 tag&#x3D;1 时，则可判断为队满</p><h2 id="2-7双端队列（deque）"><a href="#2-7双端队列（deque）" class="headerlink" title="2.7双端队列（deque）"></a>2.7双端队列（deque）</h2><p>允许两端弹出一端输入的队列或者允许两端输入一段弹出的队列</p><p>双端队列同样也是使用列表实现</p><h2 id="2-8-STL-的版本"><a href="#2-8-STL-的版本" class="headerlink" title="2.8 STL 的版本"></a>2.8 STL 的版本</h2><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol><h1 id="3-LeetCode-相关题目"><a href="#3-LeetCode-相关题目" class="headerlink" title="3.LeetCode 相关题目"></a>3.LeetCode 相关题目</h1><h2 id="3-1-232-使用栈描述队列"><a href="#3-1-232-使用栈描述队列" class="headerlink" title="3.1_232 使用栈描述队列"></a>3.1_232 使用栈描述队列</h2><h3 id="3-1-1-算法描述"><a href="#3-1-1-算法描述" class="headerlink" title="3.1.1 算法描述"></a>3.1.1 算法描述</h3><p>栈有个非常重要的逆序操作，两个栈可以实现逆序输出，而队列就是栈的逆序输出</p><p>stack_in 的作用：输入时直接输入</p><p>stack_out 的作用：当想要操作某个数据时需要将这个数据以及其前面的数据先保存到 out 中</p><p><strong>所有的元素想要操作都要先放入 out 中</strong></p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349215.gif" alt="用栈实现队列版本" style="zoom:50%;" /><p><strong>1.pop()：将队列首部的元素删除</strong></p><ul><li><p>输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据</p></li><li><p>如果输出栈不为空，则直接从出栈弹出数据就可以了。</p></li></ul><p><strong>2.peek()：返回队列首部的元素</strong></p><p>先将要操作的元素在 out 中弹出</p><p>然后再放回到 out 中</p><p><strong>3.empty()：队列判空</strong> </p><p>两个队列都为空</p><p><strong>4.push()：将一个元素放入队列的尾部</strong></p><p>正常的插入到 stack_in 中</p><p><font color='red'>每次弹出的时候从 out 中国弹出就好，不用再将 out 的放回到 in 中</font></p><h3 id="3-1-2-代码实现"><a href="#3-1-2-代码实现" class="headerlink" title="3.1.2 代码实现"></a>3.1.2 代码实现</h3><p><strong>1.C++ 代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">  stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">  <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    stIn.<span class="built_in">push</span>(x); <span class="comment">// 直接添加元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stOut.<span class="built_in">empty</span>())&#123; <span class="comment">// 如果 out 为空，则将 in 的数据全部放入 out</span></span><br><span class="line">      <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">        stIn.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = stOut.<span class="built_in">top</span>();</span><br><span class="line">    stOut.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>(); <span class="comment">// 调用自己的 pop 方法</span></span><br><span class="line">    stOut.<span class="built_in">push</span>(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stIn.<span class="built_in">empty</span>()&amp;&amp;stOut.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.Python 代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化 in 和 out 两个栈</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_in = <span class="built_in">list</span>()</span><br><span class="line">        self.stack_out = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输入时直接保存到 in 中</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack_in.append(x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        输出并移除</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1.判空</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 2.先看 out 中是否有存储元素，在 out 中没有元素后再从 in 中拿元素</span></span><br><span class="line">        <span class="keyword">if</span> self.stack_out:</span><br><span class="line">            <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop()) </span><br><span class="line">        <span class="comment"># 4.输出 out 最上面的元素</span></span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 先把这个元素弹出，然后再放入</span></span><br><span class="line">        ans = self.pop()</span><br><span class="line">        self.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (self.stack_in <span class="keyword">or</span> self.stack_out)</span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><p>常见错误：</p><p>1.在 pop 方法中，stack_in 的数据要先 pop 出去</p><h3 id="3-1-3-list-的-pop-方法"><a href="#3-1-3-list-的-pop-方法" class="headerlink" title="3.1.3 list 的  pop 方法"></a>3.1.3 list 的  pop 方法</h3><p>list 的 pop 方法可以移除并返回 list 最后一个元素</p><p><a href="https://www.runoob.com/python/att-list-pop.html">list pop 方法介绍</a></p><h2 id="3-2-225用队列实现栈"><a href="#3-2-225用队列实现栈" class="headerlink" title="3.2_225用队列实现栈"></a>3.2_225用队列实现栈</h2><h3 id="3-2-1-算法描述"><a href="#3-2-1-算法描述" class="headerlink" title="3.2.1 算法描述"></a>3.2.1 算法描述</h3><p><font color='red'><strong>栈和队列不太一样，栈是先进后出，所以用栈实现队列会导致元素的进出顺序不一样，多所以 stOut 的作用是用来调整元素的进出顺序的。但是队列是先进先出，元素输入输出顺序不变，所以第二个队列是用来数据备份的</strong></font></p><p><font color='blue'><strong>将 que1 的数据导出到 que2 ，将 que1 相应的元素弹出后再将 que2 的数据返还到 que1中</strong></font></p><p><strong>1.push</strong></p><p>直接将元素入队</p><p><strong>2.pop()：移除栈顶元素</strong></p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202062349498.gif" alt="用队列实现栈" style="zoom:50%;" /><p>这一步包含两个操作：输出值+移除</p><p>首先将 que1 中的所有元素（除最后一个）放到 que2 中，将 que1 最后一个元素弹出</p><p>这里对 que1 遍历的方法使用的是 que1 的个数，不能用 empty() 方法，因为最后一个元素需要保存在 que1 中</p><p>再将 que2 保存的那些元素再放回到 que1 中</p><p><strong>3.top()：获取栈顶元素</strong></p><p>使用 pop 方法先得到最后一个元素，然后再将最后一个元素放回去</p><p><strong>4.empty 方法</strong></p><p>因为 out 只有数据备份作用，备份完的数据还要再返回到 in 中，所以只需要对 in 判空即可</p><h3 id="3-2-2-代码实现"><a href="#3-2-2-代码实现" class="headerlink" title="3.2.2 代码实现"></a>3.2.2 代码实现</h3><p>1.C++ 代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; que2;</span><br><span class="line">  <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    que1.<span class="built_in">push</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将 que1 除最后一个元素外的所有元素放到 que2 中</span></span><br><span class="line">    <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">    size--; <span class="comment">// 最后一个元素不放</span></span><br><span class="line">    <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">      que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">      que1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 得到最后一个元素</span></span><br><span class="line">    que1.<span class="built_in">pop</span>();</span><br><span class="line">    que1 = que2; <span class="comment">// 直接赋值，不用一个个再弹出</span></span><br><span class="line">    <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      que2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que1.<span class="built_in">back</span>(); <span class="comment">// que1 的队尾元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.Python 代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义输入队列和备份队列,都是双端队列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue_in = collections.deque()</span><br><span class="line">        self.queue_out = collections.deque()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加时直接入队</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue_in.append(x)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        移除栈顶元素，并返回</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1.判空</span></span><br><span class="line">        <span class="keyword">if</span>  self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 2.先将 in 中 cur 之前的元素都备份到 out 中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.queue_in)-<span class="number">1</span>):</span><br><span class="line">            self.queue_out.append(self.queue_in.popleft())</span><br><span class="line">        <span class="comment"># 3.将 out 中备份的元素再依次放回 in 中，即 in 和 out 交换,此时 in 中保存的元素是需要出对的元素</span></span><br><span class="line">        self.queue_in,self.queue_out = self.queue_out,self.queue_in</span><br><span class="line">        <span class="comment"># 4.out 出队</span></span><br><span class="line">        <span class="keyword">return</span>  self.queue_out.popleft()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1.判空</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 2.栈：后进先出；直接返回最后一个进队的元素,不牵扯其他元素，不用备份</span></span><br><span class="line">        <span class="keyword">return</span> self.queue_in[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        判空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 因为 out 队列只用于备份，备份队列的元素最终还要送回到 in 中，所以只需要判断 in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue_in)==<span class="number">0</span></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure><h1 id="3-3-20-有效的括号"><a href="#3-3-20-有效的括号" class="headerlink" title="3.3_20 有效的括号"></a>3.3_20 有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/">LeetCode 题目链接</a></p><h3 id="3-3-1-算法描述"><a href="#3-3-1-算法描述" class="headerlink" title="3.3.1 算法描述"></a>3.3.1 算法描述</h3><p>1.三种不匹配的状况</p><p>（1）左括号多余</p><p>（2）括号没有多余，但是括号的类型没有匹配上</p><p>（3）右括号多余</p><p>2.遍历每个字符后的操作</p><p>括号匹配算法：</p><ul><li>凡出现左括弧，则对应右括号进栈</li><li>凡出现右括弧，首先检查栈是否空<br>若栈空，则表明该右括号多余（说明没有左括号匹配了）<br>栈不为空，和栈顶元素比较<br>          因为栈中只有右括号，所以 cur 如果和栈顶元素不相同则返回 false<br>          括号相同 continue</li><li>表达式检验结束时<br>若栈空，则表明表达式中匹配正确，<br>否则表明“左括弧”有余（栈不为空说明里面有右括号，右括号是因为放入了左括号导致的）</li></ul><h3 id="3-3-2-代码实现"><a href="#3-3-2-代码实现" class="headerlink" title="3.3.2 代码实现"></a>3.3.2 代码实现</h3><p>1.C++ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>); <span class="comment">// 左括号，有括号入栈</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前子字符是右括号：栈空，栈中没有要匹配的字符</span></span><br><span class="line">      <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 和 s[i] 相等，栈弹出元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>&#125; <span class="comment"># 定义一个相反逻辑的字典</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> c <span class="keyword">in</span> dic.keys():</span><br><span class="line">                <span class="keyword">if</span> stack.pop() == dic[c]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h3 id="3-3-3-时空复杂度"><a href="#3-3-3-时空复杂度" class="headerlink" title="3.3.3 时空复杂度"></a>3.3.3 时空复杂度</h3><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><h2 id="3-4-1047删除字符串中的所有相邻重复项"><a href="#3-4-1047删除字符串中的所有相邻重复项" class="headerlink" title="3.4_1047删除字符串中的所有相邻重复项"></a>3.4_1047删除字符串中的所有相邻重复项</h2><p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-zhan-jzon/">LeetCode 题目链接</a></p><h3 id="3-4-1-算法描述"><a href="#3-4-1-算法描述" class="headerlink" title="3.4.1 算法描述"></a>3.4.1 算法描述</h3><p>这道题目就像是玩过的游戏对对碰，逐渐向栈中放入元素，如果相同的元素放在挨在一起就要消除。</p><p>最后再将栈中剩余的字符串进行反转</p><p><img src="/Users/xuguagua/Documents/typora_file/gif/%5C1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif"></p><h3 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2 代码实现"></a>3.4.2 代码实现</h3><p>1.C++ </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(s);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">      result += st.<span class="built_in">top</span>();</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span> (result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 使用栈</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                <span class="comment"># 先判断 -1 元素和当前元素是否相同</span></span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>]==c:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack)</span><br></pre></td></tr></table></figure><h3 id="3-4-3-时空复杂度"><a href="#3-4-3-时空复杂度" class="headerlink" title="3.4.3 时空复杂度"></a>3.4.3 时空复杂度</h3><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><h2 id="3-5-150逆波兰表达式求值"><a href="#3-5-150逆波兰表达式求值" class="headerlink" title="3.5_150逆波兰表达式求值"></a>3.5_150逆波兰表达式求值</h2><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-zhan-9jtu/">LeetCode 题目链接</a></p><h3 id="3-5-1-算法描述"><a href="#3-5-1-算法描述" class="headerlink" title="3.5.1 算法描述"></a>3.5.1 算法描述</h3><p>逆波兰表达式其实就是后缀表达式，本题的要求相当于给出后缀表达式计算表达式的值</p><p><a href="https://blog.csdn.net/liudongdong19/article/details/80767156">如何通过后缀表达式计算数值</a></p><p>通用方法：</p><p>1.遇到数字：直接入栈</p><p>2.遇到运算符：将栈顶的两个元素出栈进行计算，<font color='red'><strong>将结果压入栈</strong></font></p><p>3.最后栈顶元素就是结果</p><h3 id="3-5-2-代码实现"><a href="#3-5-2-代码实现" class="headerlink" title="3.5.2 代码实现"></a>3.5.2 代码实现</h3><p>1.C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123; <span class="comment">// 直接判断字符</span></span><br><span class="line">        <span class="type">int</span> num1 = st.<span class="built_in">top</span>(); <span class="comment">// 得到第一个栈顶元素</span></span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> num2 = st.<span class="built_in">top</span>(); <span class="comment">// 得到第二个栈顶元素</span></span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">        <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">    st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>常见错误：</p><p>1.最后 stack 中保存的是 str 元素，需要将 return 的元素转换为 int </p><p>2.因为数字不在 0~9 之间，所以判断是否是数字还是比较麻烦。这里判断 s[i] 是否是字符串比较简单</p><p>2.Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        fuhao_list = [<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> fuhao_list:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                res = <span class="built_in">int</span>(<span class="built_in">eval</span>(<span class="string">f&#x27;<span class="subst">&#123;b&#125;</span><span class="subst">&#123;c&#125;</span><span class="subst">&#123;a&#125;</span>&#x27;</span>))</span><br><span class="line">                stack.append(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(stack[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="3-5-3-时空复杂度"><a href="#3-5-3-时空复杂度" class="headerlink" title="3.5.3 时空复杂度"></a>3.5.3 时空复杂度</h3><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><h3 id="3-5-4-Python-库实现"><a href="#3-5-4-Python-库实现" class="headerlink" title="3.5.4 Python 库实现"></a>3.5.4 Python 库实现</h3><p><strong>1.eval()</strong></p><p>执行括号中字符串的表达式</p><p><a href="https://www.runoob.com/python/python-func-eval.html">eval() 的使用</a></p><p>**2.python 字符串前的 f **</p><p>使用 {} 将一个变量进行包裹，可以将这个变量转换成值</p><p><a href="https://blog.csdn.net/qq_35290785/article/details/90634344">Python 字符串前添加 f </a></p><h2 id="3-6-239滑动窗口最大值"><a href="#3-6-239滑动窗口最大值" class="headerlink" title="3.6_239滑动窗口最大值"></a>3.6_239滑动窗口最大值</h2><h3 id="3-6-1-算法描述"><a href="#3-6-1-算法描述" class="headerlink" title="3.6.1 算法描述"></a>3.6.1 算法描述</h3><p><strong>1.暴力解：</strong></p><p>Step1：先将前 k 个元素放到队列中。</p><p>Step2：将剩余元素放到队列当中，每入队一个元素就要出队时间最长的那个元素，并且每次遍历队列的最大值，将最大值放入 res 中。</p><p>缺点：时间复杂度为 O(n*k) n 是需要遍历 nums 中的每个元素，k 是遍历滑动窗口中的每个元素</p><p><strong>2.单调队列：</strong></p><p>构建一个单调队列，里面的数值是从**<font color='red'>大到小</font>**进行排序的。并且在 index&#x3D;0 时元素最大</p><p>每次遍历一个 nums 中的元素时都需要移除单调队列中的一个老元素，并向 que 中添加当前元素。所以一共有 pop 元素和 push 元素两个操作</p><p>（1）pop 移除元素时：</p><p>每次移除下一步已经不在滑动窗口内的元素。如果要移除的元素不是最大值的元素，那这个值是否移除不会造成太大的影响，移除元素比较麻烦，所以这个元素可以不移除</p><p>（2）push 添加元素时：</p><p>如果将窗口中新添加的元素添加到队列中，要保证队列依旧单调。<font color='red'><strong>新添加的元素是一定要放入队列中的</strong>，</font>为了保证队列一直单调，所以要使用 while 循环将后面不符合单调条件的元素全部弹出，然后再将这个值放入</p><p>为什么使用单调队列而不是优先级队列，单调队列是自定义的 STL ，因为在对队列进行插入弹出操作时要保证将先进去的那个元素进行弹出</p><h3 id="3-6-2-代码实现"><a href="#3-6-2-代码实现" class="headerlink" title="3.6.2 代码实现"></a>3.6.2 代码实现</h3><p>1.C++ 代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用 deque 实现单调队列</span></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 如果想将某个值弹出，如果和队列最头上元素相等则弹出</span></span><br><span class="line">      <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;value==que.<span class="built_in">front</span>()) que.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 出队，直到可以将 value 放入合适的位置</span></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;value&gt;que.<span class="built_in">back</span>()) que.<span class="built_in">pop_back</span>();</span><br><span class="line">      <span class="comment">// 将该元素入队到合适的位置</span></span><br><span class="line">      que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// front 方法的重写</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    MyQueue que;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++) que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 先将前 k 个元素按顺序放入队列</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录最大的那个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k;i&lt;nums.<span class="built_in">size</span>();i++)&#123; <span class="comment">// 遍历后面的元素</span></span><br><span class="line">      que.<span class="built_in">pop</span>(nums[i-k]); <span class="comment">// 弹出一个元素</span></span><br><span class="line">      que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 加入这个元素</span></span><br><span class="line">      res.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录当前最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.Python 代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span>: </span><br><span class="line">        <span class="comment"># 1. 定义一个单调队列</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">            self.queue = <span class="built_in">list</span>()</span><br><span class="line">        <span class="comment"># 2.定义单调队列的入队</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self,x</span>):</span><br><span class="line">            <span class="comment"># 不断的将比 x 小的元素出队</span></span><br><span class="line">            <span class="keyword">while</span> self.queue <span class="keyword">and</span> x&gt;self.queue[-<span class="number">1</span>]:</span><br><span class="line">                self.queue.pop()</span><br><span class="line">            self.queue.append(x)</span><br><span class="line">        <span class="comment"># 3.定义单调队列的出队</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self,x</span>):</span><br><span class="line">            <span class="comment"># 为了保持单调性，并且没有那么麻烦，只有出队的元素是最大值才将元素出队</span></span><br><span class="line">            <span class="keyword">if</span> self.queue <span class="keyword">and</span> x==self.queue[<span class="number">0</span>]:</span><br><span class="line">                self.queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 4.得到最大值元素</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dandiao_que = self.MyQueue()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 1. 先将前 k 个元素全部入栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            dandiao_que.push(nums[i])</span><br><span class="line">        res.append(dandiao_que.front())</span><br><span class="line">        <span class="comment"># 2. 剩余元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums),<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 先将元素出栈</span></span><br><span class="line">            dandiao_que.pop(nums[i-k])</span><br><span class="line">            <span class="comment"># 元素入栈</span></span><br><span class="line">            dandiao_que.push(nums[i])</span><br><span class="line">            <span class="comment"># 得到当前最大值</span></span><br><span class="line">            res.append(dandiao_que.front())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="3-6-3-时空复杂度"><a href="#3-6-3-时空复杂度" class="headerlink" title="3.6.3 时空复杂度"></a>3.6.3 时空复杂度</h3><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p><h2 id="3-7-347前-K-个高频元素"><a href="#3-7-347前-K-个高频元素" class="headerlink" title="3.7_347前 K 个高频元素"></a>3.7_347前 K 个高频元素</h2><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/347-qian-k-ge-gao-pin-yuan-su-zhi-jie-pa-wemd/">LeetCode题目链接</a></p><h3 id="3-7-1-算法描述"><a href="#3-7-1-算法描述" class="headerlink" title="3.7.1 算法描述"></a>3.7.1 算法描述</h3><p>(1)整体思路</p><p>需要统计每个元素出现的频率，用 Dict &#x2F; Map  对每个元素进行<strong>计数</strong></p><p>是用优先级队列（小根堆）对出现的频率进行排序，<font color='red'>堆就是一个树</font></p><p>优先级队列类似于一个堆，只能从队头移除元素，从队尾添加元素</p><p>这里要是用小根堆对数值进行存储，这里的小跟堆只能存放 k 个元素，所以每次进行弹出时都要将堆中的最小值弹出。因为大根堆最顶部的元素是频率最高的元素，不能将频率高的元素弹出 ，所以要将频率小的值不断的移除</p><p>（2）如何构建小根堆：</p><p>小根堆本质是优先级队列，priority_map 。在定义它是要定义他的比较规则，比较规则定义如下，就相当于重写 operator 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparion</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; lhs,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.second&lt;rhs.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构建小根堆时比较规则中保证：</p><p><font color='red'><strong>left&lt;right : 从小到大–&gt;小根堆 ； right &lt;left :从大到小–&gt; 大根堆</strong></font></p><h3 id="3-7-2-代码实现"><a href="#3-7-2-代码实现" class="headerlink" title="3.7.2 代码实现"></a>3.7.2 代码实现</h3><p>1.C++ 代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">mycomparison</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; lhs,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; rhs)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lhs.second&gt;rhs.second; <span class="comment">// 构建小根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 map 统计元素出现的频率</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map; <span class="comment">// &lt;nums[i]，出现的次数&gt;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) map[nums[i]]++; <span class="comment">// 进行计数</span></span><br><span class="line">    <span class="comment">// 小跟堆：对频率进行排序</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparison&gt; pri_que;</span><br><span class="line">    <span class="comment">// 建立小跟堆</span></span><br><span class="line">    <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>();it!=map.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">      pri_que.<span class="built_in">push</span>(*it); <span class="comment">// 将这个元素添加到小根堆中</span></span><br><span class="line">      <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>()&gt;k)&#123;</span><br><span class="line">        pri_que.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历堆中元素,从后向前遍历</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      res[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">      pri_que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.Python 代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        count_dict = Counter(nums) <span class="comment"># 对每个数字出现的频率进行记录</span></span><br><span class="line">        hp = []</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> count_dict.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(hp)&lt;k: <span class="comment"># 堆中元素小于 k ，直接添加</span></span><br><span class="line">                heapq.heappush(hp,(value,key)) <span class="comment"># 因为后面要排序，所以将出现频率放在前面</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 弹出堆中最小的元素</span></span><br><span class="line">                <span class="keyword">if</span> value&gt;hp[<span class="number">0</span>][<span class="number">0</span>]: <span class="comment"># 这一维度就是 tuple 的 value 的值</span></span><br><span class="line">                    heapq.heappop(hp) <span class="comment"># 弹出最小值</span></span><br><span class="line">                    heapq.heappush(hp,(value,key)) <span class="comment"># 插入</span></span><br><span class="line">        <span class="keyword">return</span> [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> hp]</span><br></pre></td></tr></table></figure><p>常见错误：</p><p>1.对 heapq 的操作不熟悉，pop 和 push 操作时前面要加 heap</p><p>2.最后一步return 时不知道怎么写</p><h3 id="3-7-3-时空复杂度"><a href="#3-7-3-时空复杂度" class="headerlink" title="3.7.3 时空复杂度"></a>3.7.3 时空复杂度</h3><p>时间复杂度：O(nlogk)</p><p>因为堆排序的时间复杂度是 O(nlogn) ，n 是指每次需要遍历 n 个元素，logn 是指树高。但是这里的树高最坏是 logk 所以时间复杂度就是 O(nlogk )</p><p>空间复杂度：O(N)</p><h3 id="3-7-4-Python-相关库使用"><a href="#3-7-4-Python-相关库使用" class="headerlink" title="3.7.4 Python 相关库使用"></a>3.7.4 Python 相关库使用</h3><p><strong>1.Counter 计数器的使用</strong></p><p>Counter 返回一个字典，用来计算 list 中每个元素出现的次数</p><p>①导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections.Counter</span><br></pre></td></tr></table></figure><p>②对数组进行计数，并返回一个字典 dic</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dic = Counter(nums)</span><br></pre></td></tr></table></figure><p>③遍历字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.iterm()</span><br></pre></td></tr></table></figure><p><strong>2.堆的函数操作模块</strong></p><p><a href="https://blog.csdn.net/jamfiy/article/details/88185512">heapq 的介绍</a></p><p>①导包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br></pre></td></tr></table></figure><p>②构建堆</p><p>使用一个 list 构建堆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hp = []</span><br></pre></td></tr></table></figure><p>③将元素放入堆中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapq.heappush(堆数组，(元素))</span><br></pre></td></tr></table></figure><p>④弹出堆的最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapq.heappop(堆数组)</span><br></pre></td></tr></table></figure><p>1.暴力</p><p>暴力解法的话需要求 cur 的面积，以及从 cur 到最后一个柱子的最大面积。这里需要用到 <strong>短板问题</strong>，求 cur 柱子到最后一个柱子的最大面积就是  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(height[cur~n-1])*weight[cur~n-1]</span><br></pre></td></tr></table></figure><p>2.使用 DP 的思路</p><p>在前两天写了一个同样柱状图的算法，那个题是用 DP 实现的。同样也是 <font color='red'><strong>短板问题</strong></font></p><p>但是这一个题和前一个题的不同在于这个题是求实体的面积，也就是柱子的面积，而上次的题是求柱子和柱子之间缝隙的距离。所以在求最大面试时上次的题只需要知道 cur 柱子左侧的做大值和最小值是多少。但是这个题还要知道宽度，cur 到最小高度柱子的宽度是多少。所以这个题用 DP 的话除了记录 minHeight 还要记录 minWeight。</p><p><font color='red'><strong>所以这里的短板问题是要求 cur 出左右边界的</strong></font></p><p>3.单调栈</p><p>我们需要维持一个单调栈，栈中元素是递增的。每次将一个元素弹出后就要判断面积</p><p>这个栈需要保存的元素是每个柱子的 index ,因为保存 index 不仅可以知道它的高度还能求出柱子之间的宽度</p><h2 id="3-8-155-最小栈"><a href="#3-8-155-最小栈" class="headerlink" title="3.8_155 最小栈"></a>3.8_155 最小栈</h2><h3 id="3-8-1-算法描述"><a href="#3-8-1-算法描述" class="headerlink" title="3.8.1 算法描述"></a>3.8.1 算法描述</h3><p>本来是想使用一个 min_val 不断的保存最小值，但是最小值的 node 可能出栈，所以需要用一个 pair 类型保存（cur,cur_min_val），其中 cur_min_val 都是  cur 下面的元素，这些元素是还没有出栈的，所以可以直接调用</p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202212252339.png" alt="image-20220221225222563" style="zoom:33%;" /><h3 id="3-8-2-代码实现"><a href="#3-8-2-代码实现" class="headerlink" title="3.8.2 代码实现"></a>3.8.2 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) st.<span class="built_in">push</span>(&#123;val,val&#125;);</span><br><span class="line">    <span class="keyword">else</span> st.<span class="built_in">push</span>(&#123;val,<span class="built_in">min</span>(st.<span class="built_in">top</span>().second,val)&#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">top</span>().first;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st.<span class="built_in">top</span>().second;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="3-9-84最大柱形的面积"><a href="#3-9-84最大柱形的面积" class="headerlink" title="3.9_84最大柱形的面积"></a>3.9_84最大柱形的面积</h2><h3 id="3-9-1-算法描述"><a href="#3-9-1-算法描述" class="headerlink" title="3.9.1 算法描述"></a>3.9.1 算法描述</h3><p><strong>1.暴力解法</strong></p><p>假设说我们想求柱体 i 的最大面积，也就是说以 i 为高的最大面积，那就要以该主题为中心点向两边扩散，</p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202251636526.png" alt="image-20220225163643740" style="zoom:33%;" /><p>以 i 为起点，分别向左右两边扩散，直到遇到一个比 i 的高度小的柱形就停止。从而找到最大的面积块</p><img src="https://pic-1310558294.cos.ap-shanghai.myqcloud.com/img/202202251704976.png" alt="image-20220225170452924" style="zoom:33%;" /><p><strong>2.单调栈</strong></p><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/dong-hua-yan-shi-dan-diao-zhan-84zhu-zhu-03w3/">参考资料</a></p><p>这里同样可以使用单调栈的思路实现。我们从左向右不断遍历每个柱体，如果柱体之前是呈升序排列的则不断的入栈。当 i+1 的高度不满足单调时则说明 i 位置元素的面积已经可以确定了。此时就可以不断的出栈直到将 i+1放入继续满足单调栈位置。</p><p>如：上面的 6 。当我们知道柱形左边是 5 右边是 2 时 6 的最大面经就已经出来了，那就是 56 围成的面积，上面的步骤也是这么计算的。</p><h3 id="3-9-2-算法实现"><a href="#3-9-2-算法实现" class="headerlink" title="3.9.2 算法实现"></a>3.9.2 算法实现</h3><p><strong>1.暴力实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以 i 为起点，分别向左右两边扩散</span></span><br><span class="line">    <span class="type">int</span> max_res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      <span class="comment">// 判断 i 的左边</span></span><br><span class="line">      <span class="type">int</span> l = i<span class="number">-1</span>;</span><br><span class="line">      <span class="type">int</span> r = i+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;heights[l]&gt;=heights[i]) l--;</span><br><span class="line">      <span class="keyword">while</span>(r&lt;n&amp;&amp;heights[r]&gt;=heights[i]) r++;</span><br><span class="line">      <span class="type">int</span> width = r-l<span class="number">-1</span>;</span><br><span class="line">      max_res = <span class="built_in">max</span>(max_res,heights[i]*width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_res;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-9-3-时空复杂度"><a href="#3-9-3-时空复杂度" class="headerlink" title="3.9.3 时空复杂度"></a>3.9.3 时空复杂度</h3><p>1.暴力</p><p>时间复杂度：O(N2)</p><p>空间复杂度：O(1)</p><h2 id="3-10-剑指-Offer-41-数据流中的中位数"><a href="#3-10-剑指-Offer-41-数据流中的中位数" class="headerlink" title="3.10_剑指 Offer 41. 数据流中的中位数"></a>3.10_剑指 Offer 41. 数据流中的中位数</h2><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/">参考资料：评论区</a></p><h3 id="3-10-1-算法描述"><a href="#3-10-1-算法描述" class="headerlink" title="3.10.1 算法描述"></a>3.10.1 算法描述</h3><p>1.这个题有两个特点：</p><p>①容器中存放的数据是有序的，每插入一个元素后这个容器还要保证内部元素顺序不变</p><p>②快速查找到中间的数</p><p>2.具体思路：</p><p>可以使用 vector 先将数不断的存入然后每次求中位数的时候再进行排序。这样的时间复杂度是 O(N)</p><p>但是如果使用堆就可以将时间复杂度降到 O(logN)</p><p>3.使用两个堆</p><p>因为需要快速找到数据的值，所以使用使用 priority_queue ，一个大根堆一个小根堆。</p><p>**<font color='red'>原则：</font>**大根堆的根是最大元素，最大元素要比小根堆的值小。小根堆的根是最小元素，他的值要比大根堆的值大。</p><p>4.如何放入数据</p><p>首先先判断两个堆中的数据是否相等。</p><p>元素个数相等我们优先向 minHeap 中存入元素，当然也可以优先向 maxHeap 中存入元素</p><p>如果不相等， minHeap 的个数会比 maxHeap 中的元素个数多。所以元素不相等时肯定是向 maxHeap 中放入元素。</p><p>在放入元素时注意，为了保证两个堆之间的原则不变，如果想往 minHeap 中放入元素，那么放入的该元素一定保证比 maxHeap 中的最大值要大，所以在放入 minHeap 之前，要先放入 maxHeap 中将最大值元素 pop 出来</p><p>5.找到中位数</p><p>分为左右两个堆中数据是奇数还是偶数的情况</p><h3 id="3-10-2-代码实现"><a href="#3-10-2-代码实现" class="headerlink" title="3.10.2 代码实现"></a>3.10.2 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">  <span class="comment">// 创建两个堆</span></span><br><span class="line">  priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; minHeap; <span class="comment">// 小根堆</span></span><br><span class="line">  priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; maxHeap; <span class="comment">// 大根堆</span></span><br><span class="line">  <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果两边的数量不同，往右边添加元素</span></span><br><span class="line">    <span class="keyword">if</span>(minHeap.<span class="built_in">size</span>()!=maxHeap.<span class="built_in">size</span>())&#123;</span><br><span class="line">      minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">      <span class="type">int</span> val = minHeap.<span class="built_in">top</span>();</span><br><span class="line">      minHeap.<span class="built_in">pop</span>();</span><br><span class="line">      maxHeap.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 元素个数相等，优先向左边添加元素</span></span><br><span class="line">      maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">      <span class="type">int</span> val = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">      maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">      minHeap.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到中位数</span></span><br><span class="line">    <span class="type">double</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(minHeap.<span class="built_in">size</span>()!=maxHeap.<span class="built_in">size</span>())&#123;</span><br><span class="line">      mid = minHeap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">double</span> left = minHeap.<span class="built_in">top</span>();</span><br><span class="line">      <span class="type">double</span> right = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">      mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-10-3-时空复杂度"><a href="#3-10-3-时空复杂度" class="headerlink" title="3.10.3 时空复杂度"></a>3.10.3 时空复杂度</h3><p>时间复杂度：O(Nlogn)</p><p>空间复杂度：O(N)</p><h2 id="3-11-678-有效的括号字符串"><a href="#3-11-678-有效的括号字符串" class="headerlink" title="3.11_678. 有效的括号字符串"></a>3.11_678. 有效的括号字符串</h2><h3 id="3-11-1-算法描述"><a href="#3-11-1-算法描述" class="headerlink" title="3.11.1 算法描述"></a>3.11.1 算法描述</h3><p>使用两个栈的方法，一个保存左括号一个保存右括号。</p><p>这个方法是 “有效括号” 的升级方法。</p><p>从前向后遍历 s ，如果 cur 是左括号则将其放入左括号的栈，如果  cur 是 * 则将其放入 * 栈。</p><p>如果 cur 是  ）则会进行以下判断：</p><p>判断 ( 栈时我们优先去找 ( 的栈，然后再去消耗 *</p><p>​a. 空 : 不一定不匹配，还可以用 * 来充数，如果 * 都没有那就彻底没戏</p><p>​b.不为空：直接将 ( 括号弹出</p><p>那么最后可能 ( 在栈中还有剩余，这个时候 * 就有匹配 ） 的作用了。最后看看 ( 是否是在 * 之前，并且 ( 是不能比 * 多的</p><h3 id="3-11-2-代码实现"><a href="#3-11-2-代码实现" class="headerlink" title="3.11.2 代码实现"></a>3.11.2 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">checkValidString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; left_st;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; start_st;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">        left_st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">        start_st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">// 遇到右括号</span></span><br><span class="line">        <span class="keyword">if</span>(!left_st.<span class="built_in">empty</span>()) left_st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!start_st.<span class="built_in">empty</span>()) start_st.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后两个栈都不为空,同时往外弹出</span></span><br><span class="line">    <span class="keyword">while</span>(!left_st.<span class="built_in">empty</span>()&amp;&amp;!start_st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      <span class="type">int</span> a = left_st.<span class="built_in">top</span>();</span><br><span class="line">      <span class="type">int</span> b = start_st.<span class="built_in">top</span>();</span><br><span class="line">      <span class="comment">// 这里我们将 i push 进去用于判断是先放入的 (  还是先放入的 * </span></span><br><span class="line">      <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      left_st.<span class="built_in">pop</span>();</span><br><span class="line">      start_st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  left_st.<span class="built_in">empty</span>()? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-11-3-时空复杂度"><a href="#3-11-3-时空复杂度" class="headerlink" title="3.11.3 时空复杂度"></a>3.11.3 时空复杂度</h3><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 栈和队列&lt;br&gt;toc: true&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-栈-Stack&quot;&gt;&lt;a href=&quot;#1-栈-Stack&quot; class=&quot;headerlink&quot; title=&quot;1.栈 Stack&quot;&gt;&lt;/a&gt;1.栈 Stack&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://www.xuboluo666.com/2022/06/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.xuboluo666.com/2022/06/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-06-02T13:56:09.000Z</published>
    <updated>2022-06-02T13:57:44.545Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.xuboluo666.com/2022/06/02/hello-world/"/>
    <id>http://www.xuboluo666.com/2022/06/02/hello-world/</id>
    <published>2022-06-02T13:52:04.784Z</published>
    <updated>2022-06-02T13:52:04.784Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
